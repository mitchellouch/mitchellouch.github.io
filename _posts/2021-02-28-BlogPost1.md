---
layout: post
title: 'Blog Post 1: Getting to Node you'
published: true
---

Hello, welcome to a blog where I talk about learning NodeJS and why it's the greatest thing ever.

### What is NodeJS and why is it important? 

![alt text.](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Node.js_logo.svg/1200px-Node.js_logo.svg.png "nodelogo")

If you have any experience in software development, web development, or have been on the internet you've probably heard of NodeJS. But what exactly is it? Truthfully, if someone had asked me to explain it a few months ago I probably could have told them it had something to do with server-side JavaScript but that was the extent of my understanding. At the time, it seemed like this big intimidating thing that was way over my head and I didn’t really know where to start. Well, a semester of coding web applications with Java servlets was all the motivation I needed to dive further into NodeJS and I’ve discovered that it is literally the greatest thing ever (in my opinion). In this post I’d like to take you through the steps I’ve taken to learn this amazing tool and backup my very good opinion with some cold, hard facts. 

##### [Step 1: Buy NodeJS sticker for your laptop or water bottle.](https://www.redbubble.com/shop/nodejs+stickers)

The first step to becoming a legitimate NodeJS developer, is looking like a legitimate NodeJS developer. Slap that sticker on the front of your laptop to immediately increase confidence and credibility. 

##### [Step 2: Google "what is nodejs"](https://letmegooglethat.com/?q=what+is+nodejs)

So, once again, what exactly is NodeJS? When I first started talking to people about this topic, there seemed to be a lot of ambiguity around whether it was a programming language, a framework, a library, or something else entirely. A quick look at the official site tells us:

> Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine.

That answers at least one question: NodeJS is a JavaScript runtime environment. Simply put, it allows us to use JavaScript for a much wider range of applications by providing a runtime environment beyond the browser. This revelation creates endless new opportunities for JavaScript to be used in standalone applications and allows full-stack web developers to code in a single language for the front-end and back-end. But wait, there’s more! 

> Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.

Ah yes, just how I like my web apps: lightweight and efficient. If you didn't already know, thread based networking is neither of those things; using the traditional concurrency model we would have to start a new thread for each request. Since JavaScript is a "single-threaded" scripting language, this presents a huge problem for handling multiple events. Right? Nope. JavaScripts asynchronous nature lends itself perfectly to a non-blocking I/O model. Input/Output operations take time, but since NodeJS functions rarely perform these operations directly we don't need to be concerned about request volume hanging up our application. This where the true power of NodeJS lies: scalability. Since no process ever blocks, the same system could reasonably be used to handle 10 requests or 10000 requests. Here's a great example: 


```javascript
server.listen(3000, '127.0.0.1', () => {
  console.log("Server running!")
})
```


Using a callback function on a basic web server allows us to perform operations concurrently anytime a request is made to the server. Otherwise, the server simply listens and waits for requests. Ultimately, this means that if two users connect to the server, the application doesn't have to wait for the first user's request to be processed before processing the second user's request. 

> Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.

Node Package Manager (npm) is truly the cherry on top of the NodeJS sundae. Want to setup a web server with 3 lines of code instead of the usual 10 or so NodeJS requires? Throw an `npm install express --save` on the ol' command line and you're basically there. Exploring the incredible ecosystem of open source libraries you can access through npm is an excellent use of your time. 


##### Step 3: Remember JavaScript 
Full disclaimer, I love JavaScript. At the end of a long day of writing Java I love to pull the plug on the rusty old JVM, cast aside burdensome things like semicolons, and accomplish the same thing with 30% of the code. If I have my way, I will spend my career writing JavaScript. I didn’t have very much time to practice writing JavaScript during the previous semester, so I had to spend some time brushing up before I felt prepared to tackle NodeJS. Here’s a few important JavaScript concepts that greatly improved my understanding of the language, and its efficacy within the NodeJS environment:

###### 1.	Asynchronous programming 
Asynchronous programming is exactly what it sounds like: a complicated JavaScript thing. Fortunately, it’s not actually very complicated. The functions of a synchronous program are read and executed one at a time, from the top to the bottom of the code. An asynchronous program is read in the same fashion, but with one major difference: along the way, certain asynchronous functions will begin to execute concurrently to the rest of the code as it continues on another thread. This will occur for every asynchronous function in the program, which basically just means that these functions can potentially execute in any sequence unless told otherwise. Here’s a basic example using the asynchronous function `setTimeout()`:

```javascript
let user1 = Mitchell
let user2 = Bob
let user3 = Joe

console.log(user1)
console.log(user2)
console.log(user3)
```

If we executed this code, the output in the console would be:
`Mitchell`
`Bob`
`Joe`

However, if I wanted my name to appear at the end of the list (I’m Mitchell) we can use the setTimeout() function to asynchronously execute another function that says “Mitchell” after a certain amount of time. 

```javascript
setTimeout(function () {
  console.log(user1)
}, 500)
console.log(user2)
console.log(user3)
```

If we executed this code, the output in the console would be:
`Bob`
`Joe`
`Mitchell`

Meanwhile, the rest of the program continues as normal and then, once the predetermined amount (500ms in this case) of time is over, my name is added at the end of the list (even though that function is above the other two)! On one hand, this is extremely powerful for the event-driven applications we are likely to develop with NodeJS. On the other hand, without fairly extensive foresight, an asynchronous program can quickly become overcomplicated and difficult to use. Speaking of which, let's step into callback hell for a moment.

###### 2.	Callback functions 
![alt text.](https://brunolm.files.wordpress.com/2017/01/hadouken-code.jpg?w=625&h=364g "nodelogo")

Callback functions are an excellent tool for programming asynchronously. In a few words, they are functions that are passed into another function as an arguement and executed upon its completion. This is made even more useful by callback function's ability to perform further operations upon the result of its parent function. Let's take a more in depth look at the server example from earler:

```javascript
const http = require('http')
const host = '127.0.0.1'
const port = 3000

server.listen(port, host, () => {
  console.log(`Server running at http://${host}:${port}/`)
})
```

Here, we are passing the port and host (localhost:3000) into the .listen function which is asynchronously listening for http requests on the specified port. Now, what about this funny looking third argument being passed: `() => {}` This one of a few ways to use a callback function, you can write anything you want to happen when a request is processed between the {}. Essentially, the callback function that prints to the console is fired with each new connection, and if there are no connections to be processed the NodeJS runtime goes back to sleep.

###### 3.	Promises
A Promise in JavaScript is also exactly what it sounds like: we're promising to do a certain action at a later time which is either resolved or rejected. Like callback functions, promises are a useful approach to asynchronous programming because they allow us to associate events with the eventual success or failure of an asynchronous event. Rather than immediately returning a value like a synchronous function, an asynchronous function can instead return a promise to deliver the value at some point in the future. Here is an example of a basic promise:

```javascript
let promise = new Promise((resolve, reject) => {
  let user1 = Mitchell
  if (user1.equals("Mitchell")) {
    resolve("Hey, it's me.")
  } else {
    resolve("That ain't me!")
  }
})
```

If that looks different from the previous examples, it's just another syntax for using a callback function! Now all we need to do is tell the program what we want to happen when the promise is resolved:

```javascript
promise.then((message) => {
  console.log(message)
}).catch((message) => {
  console.log(message)
})
```

Anything within the `.then` method will run when our promise is resolved! In this case, the message being passed in if user1 is equal to "Mitchell" is `Hey, it's me!`. If we change the value of user1 to anything other than "Mitchell", the `.catch` method will display the message `That ain't me!` as the failure condition. 

###### 4.	Async/await 


##### Step 4: Hello World! 

##### Step 5: Oh, that's it? 


